using System;using System.Linq;using UnityEngine;using System.Collections.Generic;public static class DocketDecisions {	static List<DocketDecisionDefinition> allDecisions = new List<DocketDecisionDefinition>();	static public List<DocketDecisionDefinition> GetAll() {		Load ();		return allDecisions;	}	static public DocketDecisionDefinition GetRandom() {		Load ();		return allDecisions [UnityEngine.Random.Range(0, allDecisions.Count)];	}	static public DocketDecisionDefinition GetRandomForTopic(Topic topic) {		Load ();		List<DocketDecisionDefinition> options = allDecisions.Where( d => d.topic == topic ).ToList();		if(options.Count == 0) {			return null;		}		return options [UnityEngine.Random.Range(0, options.Count)];	}	static void Load() {		if(0 != allDecisions.Count) {			return;		}		//we haven't loaded, read the file		List<List<string>> defs = DecisionReader.ReadFile ("./Assets/Data/Decisions/Docket.txt");		foreach(List<string> def in defs) {			//has to be the right number of lines			if(def.Count != 8) {				Debug.Log ("Rejecting Docket Decision, not enough lines: " + def [0]);				continue;			}			try {				DocketDecisionDefinition d = new DocketDecisionDefinition();				d.title = def[0];				d.personType = def[1][0]; //(Follower F || Priest P) 				d.topic = TopicUtil.MapTopic(def[2]);				d.minLevel = Int32.Parse(def[3]);				d.maxLevel = Int32.Parse(def[4]);				d.options = new DecisionOption[3];				for(int i = 0; i < 3; ++i)				{					d.options[i] = new DecisionOption();					string[] parts = def[5 + i].Split(' ');					d.options[i].description = def[5 + i].Substring( 0, def[5+i].Length - parts[parts.Length-1].Length-1 );					d.options[i].value = Int32.Parse(parts[parts.Length-1]);				}				allDecisions.Add(d);			}			catch(Exception e) {				Debug.Log ("Rejecting Docket Decision, invalid: " + def [0]);				Debug.Log (e.Message);				Debug.Log ((new System.Diagnostics.StackTrace(e, true)).ToString());				continue;			}		}	}}